# TypeScript Service Template
# Based on Social MCP Server and AI-CICD MCP Server patterns

from typing import Dict, List, Any, Optional
from .base import BaseTemplate

class TypeScriptServiceTemplate(BaseTemplate):
    """Generate complete TypeScript MCP servers with service-oriented architecture"""
    
    def __init__(self):
        super().__init__(
            "typescript_service",
            "Complete TypeScript MCP server with service-oriented architecture"
        )
    
    def get_required_fields(self) -> List[str]:
        return ["name", "version"]
    
    def generate_files(self, config: Dict[str, Any]) -> Dict[str, str]:
        """Generate all TypeScript server files"""
        name = config["name"]
        version = config.get("version", "1.0.0")
        domain = config.get("domain", "custom")
        tools = config.get("tools", [])
        services = config.get("services", [])
        
        files = {}
        
        # Generate package.json
        files["package.json"] = self._generate_package_json(name, version)
        
        # Generate tsconfig.json
        files["tsconfig.json"] = self._generate_tsconfig()
        
        # Generate main server file
        files["src/index.ts"] = self._generate_server_index(name, domain, tools, services)
        
        # Generate service files based on domain
        if domain == "social":
            files["src/services/contentGenerator.ts"] = self._generate_content_generator_service()
            files["src/services/analytics.ts"] = self._generate_analytics_service()
            files["src/services/platforms.ts"] = self._generate_platform_service()
        elif domain == "cicd":
            files["src/services/requirementsProcessor.ts"] = self._generate_requirements_processor()
            files["src/services/deployment.ts"] = self._generate_deployment_service()
        
        # Generate base service
        files["src/services/base.ts"] = self._generate_base_service()
        
        # Generate types
        files["src/types/index.ts"] = self._generate_types(domain)
        
        # Generate README
        files["README.md"] = self._generate_readme(name, domain)
        
        return files
    
    def _generate_package_json(self, name: str, version: str) -> str:
        return '''{
  "name": "''' + name + '''",
  "version": "''' + version + '''",
  "description": "MCP server generated by mcp-universal-framework",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts",
    "test": "jest"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.5.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "tsx": "^4.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "keywords": ["mcp", "model-context-protocol"],
  "license": "MIT"
}'''
    
    def _generate_tsconfig(self) -> str:
        return '''{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}'''
    
    def _generate_server_index(self, name: str, domain: str, tools: List[Dict], services: List[Dict]) -> str:
        return f'''import {{ Server }} from '@modelcontextprotocol/sdk/server/index.js';
import {{ StdioServerTransport }} from '@modelcontextprotocol/sdk/server/stdio.js';
import {{
  CallToolRequestSchema,
  ListToolsRequestSchema,
}} from '@modelcontextprotocol/sdk/types.js';

// Import services
import {{ BaseService }} from './services/base.js';
''' + self._generate_service_imports(domain) + f'''

class {self._to_pascal_case(name)}Server {{
  private server: Server;
  private services: Map<string, BaseService> = new Map();

  constructor() {{
    this.server = new Server(
      {{
        name: '{name}',
        version: '1.0.0',
      }},
      {{
        capabilities: {{
          tools: {{}},
        }},
      }}
    );

    this.setupToolHandlers();
    this.setupServices();
  }}

  private async setupServices() {{
    // Initialize domain-specific services
''' + self._generate_service_setup(domain) + f'''
  }}

  private setupToolHandlers() {{
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({{
      tools: [
''' + self._generate_tool_definitions(tools) + f'''
      ],
    }}));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {{
      const {{ name, arguments: args }} = request.params;

      try {{
        switch (name) {{
''' + self._generate_tool_handlers(tools) + f'''
          default:
            throw new Error(`Unknown tool: ${{name}}`);
        }}
      }} catch (error) {{
        return {{
          content: [
            {{
              type: 'text',
              text: `Error: ${{error instanceof Error ? error.message : String(error)}}`,
            }},
          ],
        }};
      }}
    }});
  }}

  async run() {{
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(`{name} server running on stdio`);
  }}
}}

const server = new {self._to_pascal_case(name)}Server();
server.run().catch(console.error);
'''
    
    def _generate_service_imports(self, domain: str) -> str:
        if domain == "social":
            return '''import { ContentGeneratorService } from './services/contentGenerator.js';
import { AnalyticsService } from './services/analytics.js';
import { PlatformService } from './services/platforms.js';
'''
        elif domain == "cicd":
            return '''import { RequirementsProcessorService } from './services/requirementsProcessor.js';
import { DeploymentService } from './services/deployment.js';
'''
        return ""
    
    def _generate_service_setup(self, domain: str) -> str:
        if domain == "social":
            return '''    this.services.set('contentGenerator', new ContentGeneratorService());
    this.services.set('analytics', new AnalyticsService());
    this.services.set('platforms', new PlatformService());
'''
        elif domain == "cicd":
            return '''    this.services.set('requirementsProcessor', new RequirementsProcessorService());
    this.services.set('deployment', new DeploymentService());
'''
        return ""
    
    def _generate_tool_definitions(self, tools: List[Dict]) -> str:
        if not tools:
            return ""
        
        tool_defs = []
        for tool in tools:
            tool_def = f'''        {{
          name: '{tool["name"]}',
          description: '{tool["description"]}',
          inputSchema: {{
            type: 'object',
            properties: {tool.get("properties", "{}")},
            required: {tool.get("required", "[]")}
          }}
        }}'''
            tool_defs.append(tool_def)
        
        return ",\\n".join(tool_defs)
    
    def _generate_tool_handlers(self, tools: List[Dict]) -> str:
        if not tools:
            return ""
        
        handlers = []
        for tool in tools:
            handler = f'''          case '{tool["name"]}':
            const {tool["name"]}Result = await {tool.get("service_call", "this.handleGenericTool(args)")};
            return {{
              content: [{{ type: 'text', text: JSON.stringify({tool["name"]}Result) }}]
            }};'''
            handlers.append(handler)
        
        return "\\n".join(handlers)
    
    def _generate_base_service(self) -> str:
        return '''export abstract class BaseService {
  protected name: string;
  protected config: Record<string, any>;

  constructor(name: string, config: Record<string, any> = {}) {
    this.name = name;
    this.config = config;
  }

  abstract initialize(): Promise<void>;

  protected createSuccessResponse<T>(data: T, metadata?: Record<string, any>) {
    return {
      success: true,
      data,
      metadata: metadata || {}
    };
  }

  protected createErrorResponse(code: string, message: string, details?: any) {
    return {
      success: false,
      error: {
        code,
        message,
        timestamp: new Date().toISOString(),
        details
      }
    };
  }
}
'''
    
    def _generate_content_generator_service(self) -> str:
        return '''import { BaseService } from './base.js';

export class ContentGeneratorService extends BaseService {
  constructor() {
    super('contentGenerator');
  }

  async initialize(): Promise<void> {
    // Initialize content generation service
  }

  async generateContent(request: {
    platforms: string[];
    topic: string;
    tone: string;
    hashtags?: boolean;
  }) {
    try {
      const content = {
        text: `Generated ${request.tone} content about ${request.topic}`,
        platforms: request.platforms,
        hashtags: request.hashtags ? ['#trending', '#ai'] : []
      };

      return this.createSuccessResponse(content);
    } catch (error) {
      return this.createErrorResponse(
        'CONTENT_GENERATION_FAILED',
        error instanceof Error ? error.message : String(error)
      );
    }
  }
}
'''
    
    def _generate_analytics_service(self) -> str:
        return '''import { BaseService } from './base.js';

export class AnalyticsService extends BaseService {
  constructor() {
    super('analytics');
  }

  async initialize(): Promise<void> {
    // Initialize analytics service
  }

  async getAnalytics(request: {
    platforms: string[];
    timeframe: string;
    metrics: string[];
  }) {
    try {
      const analytics = {
        platforms: request.platforms,
        timeframe: request.timeframe,
        metrics: request.metrics.reduce((acc, metric) => ({
          ...acc,
          [metric]: Math.floor(Math.random() * 1000)
        }), {})
      };

      return this.createSuccessResponse(analytics);
    } catch (error) {
      return this.createErrorResponse(
        'ANALYTICS_FAILED',
        error instanceof Error ? error.message : String(error)
      );
    }
  }
}
'''
    
    def _generate_platform_service(self) -> str:
        return '''import { BaseService } from './base.js';

export class PlatformService extends BaseService {
  constructor() {
    super('platforms');
  }

  async initialize(): Promise<void> {
    // Initialize platform service
  }

  async postContent(request: {
    platform: string;
    content: string;
    scheduled?: boolean;
  }) {
    try {
      const result = {
        platform: request.platform,
        contentId: `post_${Date.now()}`,
        status: request.scheduled ? 'scheduled' : 'posted',
        url: `https://${request.platform}.com/post/${Date.now()}`
      };

      return this.createSuccessResponse(result);
    } catch (error) {
      return this.createErrorResponse(
        'POST_FAILED',
        error instanceof Error ? error.message : String(error)
      );
    }
  }
}
'''
    
    def _generate_requirements_processor(self) -> str:
        return '''import { BaseService } from './base.js';

export class RequirementsProcessorService extends BaseService {
  constructor() {
    super('requirementsProcessor');
  }

  async initialize(): Promise<void> {
    // Initialize requirements processor
  }

  async parseRequirements(request: { requirements: string }) {
    try {
      // Simple parsing logic (would be more sophisticated in real implementation)
      const parsed = {
        framework: this.extractFramework(request.requirements),
        platform: this.extractPlatform(request.requirements),
        environments: this.extractEnvironments(request.requirements)
      };

      return this.createSuccessResponse(parsed);
    } catch (error) {
      return this.createErrorResponse(
        'PARSING_FAILED',
        error instanceof Error ? error.message : String(error)
      );
    }
  }

  private extractFramework(text: string): string {
    if (text.toLowerCase().includes('flask')) return 'flask';
    if (text.toLowerCase().includes('django')) return 'django';
    if (text.toLowerCase().includes('express')) return 'express';
    return 'unknown';
  }

  private extractPlatform(text: string): string {
    if (text.toLowerCase().includes('aws')) return 'aws';
    if (text.toLowerCase().includes('azure')) return 'azure';
    if (text.toLowerCase().includes('gcp')) return 'gcp';
    return 'unknown';
  }

  private extractEnvironments(text: string): string[] {
    const environments = [];
    if (text.toLowerCase().includes('staging')) environments.push('staging');
    if (text.toLowerCase().includes('production')) environments.push('production');
    return environments.length ? environments : ['production'];
  }
}
'''
    
    def _generate_deployment_service(self) -> str:
        return '''import { BaseService } from './base.js';

export class DeploymentService extends BaseService {
  constructor() {
    super('deployment');
  }

  async initialize(): Promise<void> {
    // Initialize deployment service
  }

  async deploy(request: {
    appName: string;
    environment: string;
    config: Record<string, any>;
  }) {
    try {
      const deployment = {
        appName: request.appName,
        environment: request.environment,
        deploymentId: `deploy_${Date.now()}`,
        status: 'deploying',
        url: `https://${request.appName}-${request.environment}.example.com`
      };

      return this.createSuccessResponse(deployment);
    } catch (error) {
      return this.createErrorResponse(
        'DEPLOYMENT_FAILED',
        error instanceof Error ? error.message : String(error)
      );
    }
  }
}
'''
    
    def _generate_types(self, domain: str) -> str:
        base_types = '''export interface ServiceResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    timestamp: string;
    details?: any;
  };
  metadata?: Record<string, any>;
}

export interface BaseServiceConfig {
  [key: string]: any;
}
'''
        
        if domain == "social":
            return base_types + '''
export interface ContentRequest {
  platforms: string[];
  topic: string;
  tone: string;
  hashtags?: boolean;
}

export interface AnalyticsRequest {
  platforms: string[];
  timeframe: string;
  metrics: string[];
}

export interface PostRequest {
  platform: string;
  content: string;
  scheduled?: boolean;
}
'''
        elif domain == "cicd":
            return base_types + '''
export interface RequirementsRequest {
  requirements: string;
}

export interface DeploymentRequest {
  appName: string;
  environment: string;
  config: Record<string, any>;
}

export interface ParsedRequirements {
  framework: string;
  platform: string;
  environments: string[];
}
'''
        
        return base_types
    
    def _generate_readme(self, name: str, domain: str) -> str:
        return f'''# {name}

MCP server generated by mcp-universal-framework

## Domain: {domain}

## Installation

```bash
npm install
npm run build
```

## Running

```bash
npm start
```

## Development

```bash
npm run dev
```

## Generated with

This server was generated using the MCP Universal Framework, which extracts patterns from existing MCP servers to accelerate development.

Domain-specific features for {domain}:
''' + self._get_domain_features(domain)
    
    def _get_domain_features(self, domain: str) -> str:
        if domain == "social":
            return '''
- Content generation service
- Multi-platform analytics
- Social media posting
- Platform abstraction
'''
        elif domain == "cicd":
            return '''
- Natural language requirements parsing
- Deployment pipeline management
- Infrastructure configuration
- Multi-environment support
'''
        return '''
- Service-oriented architecture
- Professional error handling
- TypeScript type safety
- Modular design
'''
    
    def _to_pascal_case(self, text: str) -> str:
        """Convert text to PascalCase"""
        return ''.join(word.capitalize() for word in text.replace('-', '_').split('_'))
